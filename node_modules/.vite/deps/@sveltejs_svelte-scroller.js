import "./chunk-TDRWH72F.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  init,
  insert_hydration_dev,
  listen_dev,
  onMount,
  safe_not_equal,
  set_custom_element_data,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-663KAPRR.js";
import "./chunk-XSLCAIPP.js";
import "./chunk-TYRVL62N.js";

// node_modules/@sveltejs/svelte-scroller/Scroller.svelte
var { window: window_1 } = globals;
var file = "node_modules/@sveltejs/svelte-scroller/Scroller.svelte";
function add_css(target) {
  append_styles(target, "svelte-xdbafy", "svelte-scroller-outer.svelte-xdbafy{display:block;position:relative}svelte-scroller-background.svelte-xdbafy{display:block;position:relative;width:100%}svelte-scroller-foreground.svelte-xdbafy{display:block;position:relative;z-index:2}svelte-scroller-foreground.svelte-xdbafy::after{content:' ';display:block;clear:both}svelte-scroller-background-container.svelte-xdbafy{display:block;position:absolute;width:100%;max-width:100%;pointer-events:none;will-change:transform}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2Nyb2xsZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdMQyxtQ0FBc0IsQ0FDckIsT0FBTyxDQUFFLEtBQUssQ0FDZCxRQUFRLENBQUUsUUFDWCxDQUVBLHdDQUEyQixDQUMxQixPQUFPLENBQUUsS0FBSyxDQUNkLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUNSLENBRUEsd0NBQTJCLENBQzFCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLENBQ1YsQ0FFQSx3Q0FBMEIsT0FBUSxDQUNqQyxPQUFPLENBQUUsR0FBRyxDQUNaLE9BQU8sQ0FBRSxLQUFLLENBQ2QsS0FBSyxDQUFFLElBQ1IsQ0FFQSxrREFBcUMsQ0FDcEMsT0FBTyxDQUFFLEtBQUssQ0FDZCxRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxJQUFJLENBQ2YsY0FBYyxDQUFFLElBQUksQ0FJcEIsV0FBVyxDQUFFLFNBSWQiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2Nyb2xsZXIuc3ZlbHRlIl19 */");
}
var get_foreground_slot_changes = (dirty) => ({});
var get_foreground_slot_context = (ctx) => ({});
var get_background_slot_changes = (dirty) => ({});
var get_background_slot_context = (ctx) => ({});
function create_fragment(ctx) {
  let svelte_scroller_outer;
  let svelte_scroller_background_container;
  let svelte_scroller_background;
  let svelte_scroller_background_container_style_value;
  let t;
  let svelte_scroller_foreground;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[21]
  );
  const background_slot_template = (
    /*#slots*/
    ctx[20].background
  );
  const background_slot = create_slot(
    background_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_background_slot_context
  );
  const foreground_slot_template = (
    /*#slots*/
    ctx[20].foreground
  );
  const foreground_slot = create_slot(
    foreground_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_foreground_slot_context
  );
  const block = {
    c: function create() {
      svelte_scroller_outer = element("svelte-scroller-outer");
      svelte_scroller_background_container = element("svelte-scroller-background-container");
      svelte_scroller_background = element("svelte-scroller-background");
      if (background_slot)
        background_slot.c();
      t = space();
      svelte_scroller_foreground = element("svelte-scroller-foreground");
      if (foreground_slot)
        foreground_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_scroller_outer = claim_element(nodes, "SVELTE-SCROLLER-OUTER", { class: true });
      var svelte_scroller_outer_nodes = children(svelte_scroller_outer);
      svelte_scroller_background_container = claim_element(svelte_scroller_outer_nodes, "SVELTE-SCROLLER-BACKGROUND-CONTAINER", { class: true, style: true });
      var svelte_scroller_background_container_nodes = children(svelte_scroller_background_container);
      svelte_scroller_background = claim_element(svelte_scroller_background_container_nodes, "SVELTE-SCROLLER-BACKGROUND", { class: true });
      var svelte_scroller_background_nodes = children(svelte_scroller_background);
      if (background_slot)
        background_slot.l(svelte_scroller_background_nodes);
      svelte_scroller_background_nodes.forEach(detach_dev);
      svelte_scroller_background_container_nodes.forEach(detach_dev);
      t = claim_space(svelte_scroller_outer_nodes);
      svelte_scroller_foreground = claim_element(svelte_scroller_outer_nodes, "SVELTE-SCROLLER-FOREGROUND", { class: true });
      var svelte_scroller_foreground_nodes = children(svelte_scroller_foreground);
      if (foreground_slot)
        foreground_slot.l(svelte_scroller_foreground_nodes);
      svelte_scroller_foreground_nodes.forEach(detach_dev);
      svelte_scroller_outer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(svelte_scroller_background, "class", "svelte-xdbafy");
      add_location(svelte_scroller_background, file, 173, 2, 3978);
      set_custom_element_data(svelte_scroller_background_container, "class", "background-container svelte-xdbafy");
      set_custom_element_data(svelte_scroller_background_container, "style", svelte_scroller_background_container_style_value = "" + /*style*/
      (ctx[5] + /*widthStyle*/
      ctx[4]));
      add_location(svelte_scroller_background_container, file, 172, 1, 3880);
      set_custom_element_data(svelte_scroller_foreground, "class", "svelte-xdbafy");
      add_location(svelte_scroller_foreground, file, 178, 1, 4140);
      set_custom_element_data(svelte_scroller_outer, "class", "svelte-xdbafy");
      add_location(svelte_scroller_outer, file, 171, 0, 3837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_scroller_outer, anchor);
      append_hydration_dev(svelte_scroller_outer, svelte_scroller_background_container);
      append_hydration_dev(svelte_scroller_background_container, svelte_scroller_background);
      if (background_slot) {
        background_slot.m(svelte_scroller_background, null);
      }
      ctx[22](svelte_scroller_background);
      append_hydration_dev(svelte_scroller_outer, t);
      append_hydration_dev(svelte_scroller_outer, svelte_scroller_foreground);
      if (foreground_slot) {
        foreground_slot.m(svelte_scroller_foreground, null);
      }
      ctx[23](svelte_scroller_foreground);
      ctx[24](svelte_scroller_outer);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_1,
          "resize",
          /*onwindowresize*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (background_slot) {
        if (background_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            background_slot,
            background_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              background_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_background_slot_changes
            ),
            get_background_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*style, widthStyle*/
      48 && svelte_scroller_background_container_style_value !== (svelte_scroller_background_container_style_value = "" + /*style*/
      (ctx2[5] + /*widthStyle*/
      ctx2[4]))) {
        set_custom_element_data(svelte_scroller_background_container, "style", svelte_scroller_background_container_style_value);
      }
      if (foreground_slot) {
        if (foreground_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            foreground_slot,
            foreground_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              foreground_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_foreground_slot_changes
            ),
            get_foreground_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(background_slot, local);
      transition_in(foreground_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(background_slot, local);
      transition_out(foreground_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_scroller_outer);
      }
      if (background_slot)
        background_slot.d(detaching);
      ctx[22](null);
      if (foreground_slot)
        foreground_slot.d(detaching);
      ctx[23](null);
      ctx[24](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var handlers = [];
var manager;
if (typeof window !== "undefined") {
  const run_all = () => handlers.forEach((fn) => fn());
  window.addEventListener("scroll", run_all);
  window.addEventListener("resize", run_all);
}
if (typeof IntersectionObserver !== "undefined") {
  const map = /* @__PURE__ */ new Map();
  const observer = new IntersectionObserver(
    (entries, observer2) => {
      entries.forEach((entry) => {
        const update = map.get(entry.target);
        const index = handlers.indexOf(update);
        if (entry.isIntersecting) {
          if (index === -1)
            handlers.push(update);
        } else {
          update();
          if (index !== -1)
            handlers.splice(index, 1);
        }
      });
    },
    {
      rootMargin: "400px 0px"
      // TODO why 400?
    }
  );
  manager = {
    add: ({ outer, update }) => {
      const { top, bottom } = outer.getBoundingClientRect();
      if (top < window.innerHeight && bottom > 0)
        handlers.push(update);
      map.set(outer, update);
      observer.observe(outer);
    },
    remove: ({ outer, update }) => {
      const index = handlers.indexOf(update);
      if (index !== -1)
        handlers.splice(index, 1);
      map.delete(outer);
      observer.unobserve(outer);
    }
  };
} else {
  manager = {
    add: ({ update }) => {
      handlers.push(update);
    },
    remove: ({ update }) => {
      const index = handlers.indexOf(update);
      if (index !== -1)
        handlers.splice(index, 1);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let top_px;
  let bottom_px;
  let threshold_px;
  let style;
  let widthStyle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Scroller", slots, ["background", "foreground"]);
  let { top = 0 } = $$props;
  let { bottom = 1 } = $$props;
  let { threshold = 0.5 } = $$props;
  let { query = "section" } = $$props;
  let { parallax = false } = $$props;
  let { index = 0 } = $$props;
  let { count = 0 } = $$props;
  let { offset = 0 } = $$props;
  let { progress = 0 } = $$props;
  let { visible = false } = $$props;
  let outer;
  let foreground;
  let background;
  let left;
  let sections;
  let wh = 0;
  let fixed;
  let offset_top = 0;
  let width = 1;
  let height;
  let inverted;
  onMount(() => {
    sections = foreground.querySelectorAll(query);
    $$invalidate(7, count = sections.length);
    update();
    const scroller = { outer, update };
    manager.add(scroller);
    return () => manager.remove(scroller);
  });
  function update() {
    if (!foreground)
      return;
    const bcr = outer.getBoundingClientRect();
    left = bcr.left;
    $$invalidate(18, width = bcr.right - left);
    const fg = foreground.getBoundingClientRect();
    const bg = background.getBoundingClientRect();
    $$invalidate(10, visible = fg.top < wh && fg.bottom > 0);
    const foreground_height = fg.bottom - fg.top;
    const background_height = bg.bottom - bg.top;
    const available_space = bottom_px - top_px;
    $$invalidate(9, progress = (top_px - fg.top) / (foreground_height - available_space));
    if (progress <= 0) {
      $$invalidate(17, offset_top = 0);
      $$invalidate(16, fixed = false);
    } else if (progress >= 1) {
      $$invalidate(17, offset_top = parallax ? foreground_height - background_height : foreground_height - available_space);
      $$invalidate(16, fixed = false);
    } else {
      $$invalidate(17, offset_top = parallax ? Math.round(top_px - progress * (background_height - available_space)) : top_px);
      $$invalidate(16, fixed = true);
    }
    for (let i = 0; i < sections.length; i++) {
      const section = sections[i];
      const { top: top2 } = section.getBoundingClientRect();
      const next = sections[i + 1];
      const bottom2 = next ? next.getBoundingClientRect().top : fg.bottom;
      $$invalidate(8, offset = (threshold_px - top2) / (bottom2 - top2));
      if (bottom2 >= threshold_px) {
        $$invalidate(6, index = i);
        break;
      }
    }
  }
  const writable_props = [
    "top",
    "bottom",
    "threshold",
    "query",
    "parallax",
    "index",
    "count",
    "offset",
    "progress",
    "visible"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Scroller> was created with unknown prop '${key}'`);
  });
  function onwindowresize() {
    $$invalidate(0, wh = window_1.innerHeight);
  }
  function svelte_scroller_background_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      background = $$value;
      $$invalidate(3, background);
    });
  }
  function svelte_scroller_foreground_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      foreground = $$value;
      $$invalidate(2, foreground);
    });
  }
  function svelte_scroller_outer_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      outer = $$value;
      $$invalidate(1, outer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(11, top = $$props2.top);
    if ("bottom" in $$props2)
      $$invalidate(12, bottom = $$props2.bottom);
    if ("threshold" in $$props2)
      $$invalidate(13, threshold = $$props2.threshold);
    if ("query" in $$props2)
      $$invalidate(14, query = $$props2.query);
    if ("parallax" in $$props2)
      $$invalidate(15, parallax = $$props2.parallax);
    if ("index" in $$props2)
      $$invalidate(6, index = $$props2.index);
    if ("count" in $$props2)
      $$invalidate(7, count = $$props2.count);
    if ("offset" in $$props2)
      $$invalidate(8, offset = $$props2.offset);
    if ("progress" in $$props2)
      $$invalidate(9, progress = $$props2.progress);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("$$scope" in $$props2)
      $$invalidate(19, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    handlers,
    manager,
    onMount,
    top,
    bottom,
    threshold,
    query,
    parallax,
    index,
    count,
    offset,
    progress,
    visible,
    outer,
    foreground,
    background,
    left,
    sections,
    wh,
    fixed,
    offset_top,
    width,
    height,
    inverted,
    update,
    threshold_px,
    top_px,
    bottom_px,
    widthStyle,
    style
  });
  $$self.$inject_state = ($$props2) => {
    if ("top" in $$props2)
      $$invalidate(11, top = $$props2.top);
    if ("bottom" in $$props2)
      $$invalidate(12, bottom = $$props2.bottom);
    if ("threshold" in $$props2)
      $$invalidate(13, threshold = $$props2.threshold);
    if ("query" in $$props2)
      $$invalidate(14, query = $$props2.query);
    if ("parallax" in $$props2)
      $$invalidate(15, parallax = $$props2.parallax);
    if ("index" in $$props2)
      $$invalidate(6, index = $$props2.index);
    if ("count" in $$props2)
      $$invalidate(7, count = $$props2.count);
    if ("offset" in $$props2)
      $$invalidate(8, offset = $$props2.offset);
    if ("progress" in $$props2)
      $$invalidate(9, progress = $$props2.progress);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("outer" in $$props2)
      $$invalidate(1, outer = $$props2.outer);
    if ("foreground" in $$props2)
      $$invalidate(2, foreground = $$props2.foreground);
    if ("background" in $$props2)
      $$invalidate(3, background = $$props2.background);
    if ("left" in $$props2)
      left = $$props2.left;
    if ("sections" in $$props2)
      sections = $$props2.sections;
    if ("wh" in $$props2)
      $$invalidate(0, wh = $$props2.wh);
    if ("fixed" in $$props2)
      $$invalidate(16, fixed = $$props2.fixed);
    if ("offset_top" in $$props2)
      $$invalidate(17, offset_top = $$props2.offset_top);
    if ("width" in $$props2)
      $$invalidate(18, width = $$props2.width);
    if ("height" in $$props2)
      height = $$props2.height;
    if ("inverted" in $$props2)
      $$invalidate(31, inverted = $$props2.inverted);
    if ("threshold_px" in $$props2)
      threshold_px = $$props2.threshold_px;
    if ("top_px" in $$props2)
      top_px = $$props2.top_px;
    if ("bottom_px" in $$props2)
      bottom_px = $$props2.bottom_px;
    if ("widthStyle" in $$props2)
      $$invalidate(4, widthStyle = $$props2.widthStyle);
    if ("style" in $$props2)
      $$invalidate(5, style = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*top, wh*/
    2049) {
      $:
        top_px = Math.round(top * wh);
    }
    if ($$self.$$.dirty[0] & /*bottom, wh*/
    4097) {
      $:
        bottom_px = Math.round(bottom * wh);
    }
    if ($$self.$$.dirty[0] & /*threshold, wh*/
    8193) {
      $:
        threshold_px = Math.round(threshold * wh);
    }
    if ($$self.$$.dirty[0] & /*top, bottom, threshold, parallax*/
    47104) {
      $:
        top, bottom, threshold, parallax, update();
    }
    if ($$self.$$.dirty[0] & /*fixed, offset_top*/
    196608) {
      $:
        $$invalidate(5, style = `
		position: ${fixed ? "fixed" : "absolute"};
		top: 0;
		transform: translate(0, ${offset_top}px);
		z-index: ${inverted ? 3 : 1};
	`);
    }
    if ($$self.$$.dirty[0] & /*fixed, width*/
    327680) {
      $:
        $$invalidate(4, widthStyle = fixed ? `width:${width}px;` : "");
    }
  };
  return [
    wh,
    outer,
    foreground,
    background,
    widthStyle,
    style,
    index,
    count,
    offset,
    progress,
    visible,
    top,
    bottom,
    threshold,
    query,
    parallax,
    fixed,
    offset_top,
    width,
    $$scope,
    slots,
    onwindowresize,
    svelte_scroller_background_binding,
    svelte_scroller_foreground_binding,
    svelte_scroller_outer_binding
  ];
}
var Scroller = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        top: 11,
        bottom: 12,
        threshold: 13,
        query: 14,
        parallax: 15,
        index: 6,
        count: 7,
        offset: 8,
        progress: 9,
        visible: 10
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Scroller",
      options,
      id: create_fragment.name
    });
  }
  get top() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get threshold() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set threshold(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get query() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set query(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parallax() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parallax(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get index() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get progress() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Scroller_default = Scroller;
export {
  Scroller_default as default
};
//# sourceMappingURL=@sveltejs_svelte-scroller.js.map
